#include "stm32f3xx_hal.h"
#include <ACAN_STM32.h>

// === Définition des broches OUTPUT ===
#define RED_LED_PORT    GPIOA
#define RED_LED_PIN     GPIO_PIN_5

#define YELLOW_LED_PORT GPIOA
#define YELLOW_LED_PIN  GPIO_PIN_4

#define GREEN_LED_PORT  GPIOA
#define GREEN_LED_PIN   GPIO_PIN_3

#define BUZZER_PORT     GPIOB
#define BUZZER_PIN      GPIO_PIN_6 // couper PB7, relier à PB6

#define ELECTROMAGNET_PORT     GPIOA
#define ELECTROMAGNET_PIN      GPIO_PIN_10
// -- to do
#define FIRING_VALVE_PORT     GPIOA
#define FIRING_VALVE_PIN      GPIO_PIN_1

#define EXHAUST_VALVE_PORT     GPIOB
#define EXHAUST_VALVE_PIN      GPIO_PIN_3

#define TRIGGER_PORT     GPIOB
#define TRIGGER_PIN      GPIO_PIN_0

// === Définition des broches INPUT ===
#define BUTTON_EMERGENCY_STOP_PORT GPIOA
#define BUTTON_EMERGENCY_STOP_PIN  GPIO_PIN_7

#define INT_EMERGENCY_STOP_PORT    GPIOB
#define INT_EMERGENCY_STOP_PIN     GPIO_PIN_5

#define END_STOP_PORT    GPIOA
#define END_STOP_PIN     GPIO_PIN_9
// -- to do
#define EXHAUST_BUTTON_PORT    GPIOA   // mettre un pull up
#define EXHAUST_BUTTON_PIN     GPIO_PIN_6

// === ADC ==
#define PRESSURE_SENSOR_PIN PA0

// === PWM ===
#define ADMISSION_VALVE_PORT    GPIOB   // mettre un pull up
#define ADMISSION_VALVE_PIN     GPIO_PIN_4

// === Structure GPIO ===
GPIO_InitTypeDef GPIO_InitStruct;
TIM_HandleTypeDef htim3;
TIM_OC_InitTypeDef sConfigOC;

static uint32_t gSendDate = 0;
static uint32_t gSentCount = 0;
static uint32_t gReceivedCount = 0;

void setup_can() {
  // Configuration du CAN à 125 kbit/s
  ACAN_STM32_Settings settings(125 * 1000);
  
  // En mode normal
  settings.mModuleMode = ACAN_STM32_Settings::NORMAL;
  
  // Débogage (optionnel)
  Serial.print("Bit Rate prescaler: ");
  Serial.println(settings.mBitRatePrescaler);
  Serial.print("Actual Bit Rate: ");
  Serial.print(settings.actualBitRate());
  Serial.println(" bit/s");
  
  // Initialisation du CAN
  const uint32_t errorCode = can.begin(settings);
  if (errorCode == 0) {
    Serial.println("CAN initialization successful");
    
  } else {
    Serial.print("CAN initialization failed, error code: 0x");
    Serial.println(errorCode, HEX);
    
  }
}


// Fonction pour envoyer un message CAN
void send_can_message(uint16_t id, uint8_t *data, uint8_t length) {
  CANMessage message;
  message.id = id;
  message.len = length;
  
  // Copier les données
  for (uint8_t i = 0; i < length && i < 8; i++) {
    message.data[i] = data[i];
  }
  
  if (can.tryToSendReturnStatus(message)) {
    gSentCount++;
    Serial.print("Message sent, count: ");
    Serial.println(gSentCount);
  } else {
    Serial.println("Failed to send CAN message");
  }
}

// Fonction pour lire les messages CAN disponibles
void read_can_messages() {
  CANMessage receivedMsg;
  while (can.receive0(receivedMsg)) {
    gReceivedCount++;
    
    // Afficher les infos du message reçu
    Serial.print("Message received, ID: 0x");
    Serial.print(receivedMsg.id, HEX);
    Serial.print(", Length: ");
    Serial.print(receivedMsg.len);
    Serial.print(", Data: ");
    
    for (uint8_t i = 0; i < receivedMsg.len; i++) {
      Serial.print("0x");
      if (receivedMsg.data[i] < 16) Serial.print("0");
      Serial.print(receivedMsg.data[i], HEX);
      Serial.print(" ");
    }
    Serial.println();
  }
}

void setup_pwm() {
  // Activation de l'horloge du timer
  __HAL_RCC_TIM3_CLK_ENABLE();
  
  // Configuration de base du timer
  htim3.Instance = TIM3;
  // Avec un APB1 à 8MHz (par défaut pour STM32F303), 
  // Pour obtenir 500Hz: 8000000 / (16000 * 1) = 500Hz
  htim3.Init.Prescaler = 15;               // Prescaler = 16-1
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim3.Init.Period = 999;                 // Period = 1000-1
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  
  if (HAL_TIM_PWM_Init(&htim3) != HAL_OK) {
    // Gestion d'erreur
    HAL_GPIO_WritePin(RED_LED_PORT, RED_LED_PIN, GPIO_PIN_SET);
    while(1);
  }
  
  // Configuration du canal de sortie PWM (PB4 est connecté à TIM3_CH1)
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 500;  // Duty cycle de 50% (500/1000)
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1) != HAL_OK) {
    // Gestion d'erreur
    HAL_GPIO_WritePin(RED_LED_PORT, RED_LED_PIN, GPIO_PIN_SET);
    while(1);
  }
  
  // Configuration de PB4 en fonction alternative (AF2 pour TIM3_CH1)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  
  // Activation de l'horloge pour GPIOB (déjà fait dans votre code d'origine)
  //__HAL_RCC_GPIOB_CLK_ENABLE();
  
  GPIO_InitStruct.Pin = ADMISSION_VALVE_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;  // AF2 correspond à TIM3 pour PB4
  
  HAL_GPIO_Init(ADMISSION_VALVE_PORT, &GPIO_InitStruct);
  
  // Démarrage du PWM
  HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);
}

void set_admission_valve_duty(uint8_t duty_percent) {
  if (duty_percent > 100) duty_percent = 100;
  
  uint32_t pulse = (uint32_t)(((htim3.Init.Period + 1) * duty_percent) / 100);
  __HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_1, pulse);
}

void setup() {
  Serial.begin(115200);
  HAL_Init();

  // Activer les horloges des GPIOs utilisés
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  
  setup_pwm();
  
  
  // === LEDs ===
  GPIO_InitStruct.Pin = RED_LED_PIN | YELLOW_LED_PIN | GREEN_LED_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  // === BUZZER ===
  GPIO_InitStruct.Pin = BUZZER_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(BUZZER_PORT, &GPIO_InitStruct);

  // === ELECTROMAGNET ===
  GPIO_InitStruct.Pin = ELECTROMAGNET_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(ELECTROMAGNET_PORT, &GPIO_InitStruct);
  // -- to do
  GPIO_InitStruct.Pin = FIRING_VALVE_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(FIRING_VALVE_PORT, &GPIO_InitStruct);

  GPIO_InitStruct.Pin = EXHAUST_VALVE_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(EXHAUST_VALVE_PORT, &GPIO_InitStruct);

  GPIO_InitStruct.Pin = TRIGGER_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(TRIGGER_PORT, &GPIO_InitStruct);

  // === Boutons en INPUT ===
  analogReadResolution(12); //max 12. PB0 en conflit avec pa7 BUTTON_EMERGENCY_STOP, à initialiser avant, comme ici
  GPIO_InitStruct.Pin = BUTTON_EMERGENCY_STOP_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(BUTTON_EMERGENCY_STOP_PORT, &GPIO_InitStruct);
  
  GPIO_InitStruct.Pin = INT_EMERGENCY_STOP_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(INT_EMERGENCY_STOP_PORT, &GPIO_InitStruct);

  GPIO_InitStruct.Pin = END_STOP_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(END_STOP_PORT, &GPIO_InitStruct);
  // -- to do
  GPIO_InitStruct.Pin = EXHAUST_BUTTON_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  HAL_GPIO_Init(EXHAUST_BUTTON_PORT, &GPIO_InitStruct);

  setup_can();

  

  // === Test LEDs & Buzzer ===
  HAL_GPIO_WritePin(RED_LED_PORT, RED_LED_PIN, GPIO_PIN_SET);
  HAL_Delay(100);
  HAL_GPIO_WritePin(RED_LED_PORT, RED_LED_PIN, GPIO_PIN_RESET);
  HAL_Delay(100);
  HAL_GPIO_WritePin(YELLOW_LED_PORT, YELLOW_LED_PIN, GPIO_PIN_SET);
  HAL_Delay(100);
  HAL_GPIO_WritePin(YELLOW_LED_PORT, YELLOW_LED_PIN, GPIO_PIN_RESET);
  HAL_Delay(100);
  HAL_GPIO_WritePin(GREEN_LED_PORT, GREEN_LED_PIN, GPIO_PIN_SET);
  HAL_Delay(100);
  HAL_GPIO_WritePin(GREEN_LED_PORT, GREEN_LED_PIN, GPIO_PIN_RESET);
  HAL_Delay(100);

  HAL_GPIO_WritePin(BUZZER_PORT, BUZZER_PIN, GPIO_PIN_SET);
  HAL_Delay(50);
  HAL_GPIO_WritePin(BUZZER_PORT, BUZZER_PIN, GPIO_PIN_RESET);
  HAL_Delay(50);
  HAL_GPIO_WritePin(BUZZER_PORT, BUZZER_PIN, GPIO_PIN_SET);
  HAL_Delay(50);
  HAL_GPIO_WritePin(BUZZER_PORT, BUZZER_PIN, GPIO_PIN_RESET);

  
}

void loop() {
  // Blink LED verte
  HAL_GPIO_TogglePin(GREEN_LED_PORT, GREEN_LED_PIN);
  HAL_GPIO_TogglePin(ELECTROMAGNET_PORT, ELECTROMAGNET_PIN);
  // -- to do
  HAL_GPIO_TogglePin(FIRING_VALVE_PORT, FIRING_VALVE_PIN);
  HAL_GPIO_TogglePin(EXHAUST_VALVE_PORT, EXHAUST_VALVE_PIN);
  HAL_GPIO_TogglePin(TRIGGER_PORT, TRIGGER_PIN);
  HAL_Delay(500);

  // Lire les entrées et afficher dans le moniteur série (si activé)
  int EMERGENCY_STOP = HAL_GPIO_ReadPin(BUTTON_EMERGENCY_STOP_PORT, BUTTON_EMERGENCY_STOP_PIN);
  int INT_EMERGENCY_STOP = HAL_GPIO_ReadPin(INT_EMERGENCY_STOP_PORT, INT_EMERGENCY_STOP_PIN);
  int END_STOP = HAL_GPIO_ReadPin(END_STOP_PORT, END_STOP_PIN);
  // -- to do
  int EXHAUST_BUTTON = HAL_GPIO_ReadPin(EXHAUST_BUTTON_PORT, EXHAUST_BUTTON_PIN);
  uint32_t PRESSURE_SENSOR = analogRead(PRESSURE_SENSOR_PIN); 

  // Affiche dans le moniteur si tu as Serial.begin dans ton sketch
  Serial.print("EMERGENCY_STOP: ");
  Serial.print(EMERGENCY_STOP);
  Serial.print(" | INT: ");
  Serial.print(INT_EMERGENCY_STOP);
  Serial.print(" | END_STOP: ");
  Serial.print(END_STOP);
  // -- to do
  Serial.print(" | EXHAUST_BUTTON: ");
  Serial.print(EXHAUST_BUTTON);
  Serial.print(" | PRESSURE_SENSOR: ");
  Serial.println(PRESSURE_SENSOR);

  set_admission_valve_duty(50); // le positionner pas n'importe où

  if (gSendDate < HAL_GetTick()) {
    uint8_t data[8] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
    send_can_message(0x123, data, 8); // ID 0x123, 8 octets de données
    
    // Programmer le prochain envoi dans 1000ms
    gSendDate = HAL_GetTick() + 1000;
  }
  
  // Vérifier si des messages ont été reçus
  read_can_messages();
}